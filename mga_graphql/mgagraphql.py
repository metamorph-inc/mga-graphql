import xml.etree.ElementTree as ET
import _winreg as winreg
import os
import sys
import udm

import collections
import functools


class MgaGraphQlSchemaConverter(object):
    TEMPLATE_CLASS = """# auto-generated by mga-graphql
from mga_graphql.mgaclasses import *
from graphene import String, Int, Field, Boolean, List
{imports}


class {classname}({baseclasses}):
    {attributes}
"""

    TEMPLATE_IMPORT = """from .{classname} import {classname}"""

    RELPATH_DSML_CLASSES = 'dsmlclasses'

    MGA_CLASSES = ['MgaObject', 'MgaFco',
                   'MgaModel', 'MgaAtom',
                   'MgaReference', 'MgaSet',
                   'MgaFolder', 'MgaConnection']

    def __init__(self, udm_xml=None):
        self.parse_metamodel(udm_xml)

    def build_class_file(self, classname, baseclasses, attributes):
        if baseclasses:
            imports = '\n'.join([self.TEMPLATE_IMPORT.format(classname=bc)
                                 for bc in baseclasses
                                 if bc not in self.MGA_CLASSES])
            list_baseclasses = ', '.join(baseclasses)
        else:
            imports = ''
            list_baseclasses = ''

        if attributes:
            code_attributes = '\n    '.join(['{name} = {type}()'.format(name=k,
                                                                        type=v)
                                             for k, v in attributes.iteritems()])
        else:
            code_attributes = 'pass'

        code_class = self.TEMPLATE_CLASS.format(classname=classname,
                                                baseclasses=list_baseclasses,
                                                attributes=code_attributes,
                                                imports=imports)
        print (code_class)
        print ('\n')

        path_classfile = os.path.join(self.RELPATH_DSML_CLASSES, classname + '.py')
        with open(path_classfile, 'w') as cf:
            cf.writelines(code_class)

    TEMPLATE_QUERY_FILE = """# auto-generated by mga-graphql
import graphene
from mga_graphql.mgaclasses import *
from dsmlclasses import *
import udm


def load_data(path_mga, path_udm_xml):
    uml_diagram = udm.uml_diagram()
    meta_dn = udm.SmartDataNetwork(uml_diagram)
    meta_dn.open(path_udm_xml.encode('utf-8'), b'')
    dn = udm.SmartDataNetwork(meta_dn.root)
    dn.open(path_mga.encode('utf-8'), b'')

    # Need to make our own data structure for now.
    models = {{}}
    root = dn.root

    def visit(obj):
        type = obj.type.name

        if type == 'Compound':
            model = Compound(id=obj.id,
                             name=obj.name)
        else:
            model = MgaObject(id=obj.id,
                              name=obj.name)

        models[str(obj.id)] = model

        child_ids = []
        for child in obj.children():
            child_ids.append(visit(child))

        if type == 'Compound':
            model.children = child_ids

        return obj.id

    visit(dn.root)

    return models


class Query(graphene.ObjectType):
    {objects}
    

def run_server(d_models):
    schema = graphene.Schema(query=Query)

    from flask import Flask, render_template
    from flask_graphql import GraphQLView

    app = Flask(__name__)
    app.debug = False

    app.add_url_rule('/graphql',
                     view_func=GraphQLView.as_view('graphql',
                                                   schema=schema,
                                                   graphiql=True,
                                                   context={{
                                                       'session': Query,
                                                       'data': d_models
                                                   }}))

    @app.route('/')
    def index():
        return "Go to /graphql"

    app.run()
"""

    def build_query_file_entry(self, l_classes):
        template_objects = """
    {lowercase} = graphene.Field({classname}, id=graphene.String(),)
    def resolve_{lowercase}(self, info, id):
        return info.context['data'][id]
    
    all_{lowercase} = graphene.List({classname}, )
    def resolve_all_{lowercase}(self, info):
        return [v for k, v in info.context['data'].iteritems()
                if isinstance(v, {classname})]        
"""

        code_schema = self.TEMPLATE_QUERY_FILE.format(objects='\n'
                                                      .join([template_objects.format(lowercase=c.lower(),
                                                                                     classname=c)
                                                             for c in l_classes]))
        print (code_schema)

        path_schemafile = os.path.join('schema.py')
        with open(path_schemafile, 'w') as cf:
            cf.writelines(code_schema)

    def parse_metamodel(self, udm_xml):
        tree = ET.parse(udm_xml)
        root = tree.getroot()

        # Build classes for everything
        path_dsml_classes = self.RELPATH_DSML_CLASSES
        # if os.path.exists(path_dsml_classes):
        #     os.remove(path_dsml_classes)
        # os.mkdir(path_dsml_classes)

        # Build class dict
        m_classes = {clazz.get('_id'): clazz.get('name') for clazz in root.iter('Class')}

        # Build class code files
        for clazz in root.iter('Class'):
            name_class = clazz.get('name')

            # Skip Mga classes (already included)
            if name_class in self.MGA_CLASSES:
                continue

            # Get baseclasses
            baseclass_names = []
            basetypes = clazz.get('baseTypes')
            if basetypes:
                baseclass_names = [m_classes[id] for id in basetypes.split(' ')
                                   if m_classes[id] not in self.MGA_CLASSES]

            # Also flag the MGA basetype
            baseclass_names.append('Mga' + clazz.attrib['stereotype'])

            m_attr = {}
            for attr in clazz.iter('Attribute'):
                name_attr = attr.get('name')
                type_attr = attr.get('type')
                if type_attr == 'Integer':
                    m_attr[name_attr] = 'Int'
                else:
                    m_attr[name_attr] = type_attr

            if not baseclass_names:
                baseclass_names = ['MgaObject']

            self.build_class_file(name_class, baseclass_names, m_attr)

        l_dsml_classes = [v for k, v in m_classes.iteritems()
                          if v not in self.MGA_CLASSES]

        # Build dsmlclasses/__init__.py
        code_init = '\n'.join(["from .{cname} import {cname}".format(cname=cname)
                               for cname in l_dsml_classes])
        with open(os.path.join('dsmlclasses', '__init__.py'), 'w') as init:
            init.writelines(code_init)

        # Build schema file
        self.build_query_file_entry(l_dsml_classes)
